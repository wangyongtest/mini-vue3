{"version":3,"file":"compiler-dom.global.js","sources":["../src/index.ts"],"sourcesContent":["\r\n\r\n/**5、**/\r\n// 是否解析完成. 解析完成的依据 ctx.source === ''\r\nexport const isEnd = (ctx) => {\r\n    const source = ctx.source\r\n    // 当以 </ 开头，说明没有子元素，直接结束\r\n    if (ctx.source.startsWith('</')) {\r\n        return true\r\n    }\r\n    return !source\r\n}\r\n\r\n\r\nfunction getCursor(ctx) {\r\n    const { line, column, offset } = ctx\r\n\r\n    return {\r\n        line,\r\n        column,\r\n        offset\r\n    }\r\n}\r\n\r\nfunction advancePositionWithMutation(content, s, endIndex) {\r\n    // 如何更新行， 如何更新列\r\n    let linesCount = 0\r\n    let linePos = -1\r\n    for (let i = 0; i < endIndex; i++) {\r\n        if (s.charCodeAt(i) === 10) {\r\n            linesCount++\r\n            linePos = i\r\n        }\r\n    }\r\n    // console.log(linesCount, 'linesCount');\r\n    // 更新 行列信息\r\n    content.offset += endIndex\r\n    content.line += linesCount\r\n    content.column = linePos === -1 ? content.column + endIndex : endIndex - linePos\r\n    // console.log(content);\r\n\r\n\r\n}\r\n\r\n\r\nfunction advanceBy(content, endIndex) {\r\n    // \r\n    let s = content.source\r\n    // 计算出一个新的结束位置,根据内容和索引来修改上下文的信息\r\n    advancePositionWithMutation(content, s, endIndex)\r\n    content.source = s.slice(endIndex)\r\n}\r\n\r\nfunction parseTextData(content, endIndex) {\r\n    // 这里就拿到了原文本\r\n    const rowText = content.source.slice(0, endIndex)\r\n    // 前进，解析完了之后，游标向前移动\r\n    advanceBy(content, endIndex)\r\n    return rowText\r\n}\r\n\r\n\r\n\r\nfunction advanceSpace(ctx) {\r\n    const match = /^[ \\t\\r\\n/>]+/.exec(ctx.source)\r\n    if (match) {\r\n        advanceBy(ctx, match[0].length)\r\n    }\r\n}\r\n\r\nfunction parseTag(ctx) {\r\n    const start = getCursor(ctx)\r\n    // 解析标签\r\n    //  以 空格 \\t \\r \\n / 开头\r\n    const match = /^<\\/?([a-z][^ \\t\\r\\n/>]*)/.exec(ctx.source)\r\n    const tag = match[1]\r\n    advanceBy(ctx, match[0].length)\r\n    // 前进空格 <div >\r\n    advanceSpace(ctx)\r\n\r\n    // 查看标签是不是自闭合标签\r\n    const isSelfClosing = ctx.source.startsWith('/>')\r\n    advanceBy(ctx, isSelfClosing ? 2 : 1)\r\n    console.log(tag, 'tag');\r\n\r\n    return {\r\n        type: 5,\r\n        tag,\r\n        isSelfClosing,\r\n        loc: getSelection(ctx, start)\r\n    }\r\n\r\n\r\n}\r\n\r\n/**分支解析**/\r\nfunction parseElement(ctx) {\r\n    // 1、解析标签名\r\n    let ele: any = parseTag(ctx)\r\n\r\n    const children = parseChildren(ctx)\r\n    // 2、解析完标签\r\n    if (ctx.source.startsWith('</')) {\r\n        parseTag(ctx)\r\n    }\r\n\r\n    ele.children = children\r\n    ele.loc = getSelection(ctx, ele.loc.start)\r\n\r\n    return ele\r\n\r\n}\r\n\r\n\r\nfunction parseInterpolation(ctx) {\r\n\r\n    const start = getCursor(ctx)\r\n\r\n    // 首先确定 结束位置\r\n    const closeIndex = ctx.source.indexOf('}}', '{{')\r\n\r\n    advanceBy(ctx, 2)\r\n\r\n    const innerStart = getCursor(ctx)\r\n    const innerEnd = getCursor(ctx)\r\n    const rawContextLength = closeIndex - 2 // 拿到 ｛｛内容｝｝ 包含空格\r\n\r\n    const preTrimContent = parseTextData(ctx, rawContextLength)\r\n    const content = preTrimContent.trim()\r\n\r\n    const startOffset = preTrimContent.indexOf(content)\r\n    // startOffset 大于0 时说明有空格\r\n    if (startOffset > 0) {\r\n        // \r\n        advancePositionWithMutation(innerStart, preTrimContent, startOffset)\r\n    }\r\n    // 然后去更新 结束偏移量\r\n    const endOffset = content.length + startOffset\r\n    advancePositionWithMutation(innerEnd, preTrimContent, endOffset)\r\n    advanceBy(ctx, 2)\r\n    // console.log(content);\r\n\r\n    return {\r\n        type: 5,\r\n        content: {\r\n            type: 4, // 表达式\r\n            isStatic: false,\r\n            loc: getSelection(ctx, innerStart, innerEnd)\r\n        },\r\n        loc: getSelection(ctx, start)\r\n    }\r\n}\r\n\r\n\r\n//获取信息对应的 开始 结束 内容\r\nfunction getSelection(content, start, end?) {\r\n    end = end || getCursor(content)\r\n    return {\r\n        start: start,\r\n        end,\r\n        source: content.originalSource.slice(start.offset, end.offset)\r\n    }\r\n}\r\n\r\nfunction parseText(ctx) {\r\n    // 01、\r\n    const endTokens = ['<', '{{']\r\n    let endIndex = ctx.source.length\r\n    // 获取文本整个长度 hello{{xxx}} <div></div>\r\n    const index = ctx.source.length\r\n    for (let i = 0; i < endTokens.length; i++) {\r\n\r\n        // indexOf 搜索指定子字符串，并返回其第一次出现的位置索引\r\n        const index = ctx.source.indexOf(endTokens[i])\r\n        if (index > -1 && endIndex > index) {\r\n            endIndex = index\r\n        }\r\n    }\r\n\r\n    // console.log(endIndex, 'endIndex', ctx.source)\r\n    // 有了文本的结束位置，就可以更新行列信息\r\n    const start = getCursor(ctx)\r\n    const content = parseTextData(ctx, endIndex)\r\n\r\n    // console.log(content.source, start);\r\n\r\n\r\n\r\n    return {\r\n        type: 2, // 类型\r\n        content,\r\n        loc: getSelection(ctx, start)\r\n    }\r\n\r\n}\r\n\r\n\r\n/**4、***/\r\nexport const parseChildren = (ctx) => {\r\n    // \r\n    const nodes = []\r\n\r\n    while (!isEnd(ctx)) {\r\n        // 当前上下文中的内容\r\n        const s = ctx.source\r\n        let node;\r\n        if (s.startsWith('<')) { // 标签\r\n            node = parseElement(ctx)\r\n        } else if (s.startsWith('{{')) { // 插值语法(表达式)\r\n            node = parseInterpolation(ctx)\r\n        } else {\r\n            // 其余全部为文本\r\n            node = parseText(ctx)\r\n        }\r\n        nodes.push(node)\r\n    }\r\n\r\n    // console.log(nodes);\r\n\r\n    return nodes\r\n}\r\n\r\n/**3、**/\r\nexport const createParseContext = (temp) => {\r\n    // \r\n    return {\r\n        line: 1,\r\n        column: 1,\r\n        offset: 0,\r\n        source: temp, // 这个source会不停的移除等待 source 为空，说明解析完成\r\n        originalSource: temp // 这个值是不会变的，记录传入的内容\r\n    }\r\n}\r\n\r\n\r\n\r\n/** 2、**/\r\nexport const baseParse = (temp) => {\r\n    // 标识节点信息 ：行 列 偏移量……\r\n    // 每解析一段，就移除一部分\r\n\r\n    const context = createParseContext(temp)\r\n    // 这里解析时增加一个 根节点\r\n    // return createRoot(temp, parseChildren(context))\r\n\r\n    return parseChildren(context)\r\n}\r\n\r\n\r\n\r\n/**1、**/\r\nexport const baseCompiler = (temp) => {\r\n    // 1、将模版解析为 render 函数\r\n    const ast = baseParse(temp)\r\n\r\n    return ast\r\n\r\n}\r\n\r\n"],"names":[],"mappings":"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"}