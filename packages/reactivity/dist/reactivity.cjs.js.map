{"version":3,"file":"reactivity.cjs.js","sources":["../../shared/src/index.ts","../src/effect.ts","../src/baseHandlers.ts","../src/reactive.ts","../src/ref.ts","../src/computed.ts"],"sourcesContent":["// 判断是否为对象，切不能为 null\r\nconst isObject = (value)=> typeof value === 'object'&&value!== null\r\nconst extend = Object.assign\r\nconst isArray = Array.isArray\r\nconst isFunction = (value)=> typeof value === 'function'\r\nconst isNumber = value => typeof value === 'number'\r\nconst isString = value => typeof value === 'string'\r\nconst isIntegerKey = key => parseInt(key) + '' === key // 整形字符串 => 索引(更新索引)\r\n\r\n// \r\nlet hasOwnProperty = Object.prototype.hasOwnProperty\r\nconst hasOwn = (target,key)=> hasOwnProperty.call(target,key)\r\n\r\nconst hasChanged = (newVal, oldVal) => newVal !== oldVal\r\n\r\n\r\nexport {\r\n    isObject,\r\n    extend,\r\n    isArray,\r\n    isFunction,\r\n    isNumber,\r\n    isString,\r\n    isIntegerKey,\r\n    hasOwn,\r\n    hasChanged\r\n}","import { isArray,isIntegerKey } from \"@vue/shared\";\r\nimport { triggerOrTypes } from \"./operators\";\r\n\r\n// effect 接收两个参数， 第一为函数，第二个为配置项\r\nexport function effect(fn, options: any = {}) {\r\n  // 目的：让effect变为响应式，数据变化进行重新执行\r\n  const effect = createReactiveEffect(fn, options);\r\n\r\n  // 如果属性中由lazy，说明是懒执行，首次不执行，柔则执行\r\n\r\n  if (!options.lazy) {\r\n    // 响应式默认会执行一次\r\n    effect();\r\n  }\r\n\r\n  return effect;\r\n}\r\n\r\n// 给 effect 添加标识(全局标识)\r\nlet uid = 0;\r\nlet activeEffect; // 存储当前的effect\r\nconst effectStack = [];\r\nfunction createReactiveEffect(fn, options) {\r\n  const effect = function reactiveEffect() {\r\n    // 解决场景二\r\n    // 判断栈中是否存在 effect, 不存在则放入栈中【保证effect没有加入到effectStack中】\r\n    if (!effectStack.includes(effect)) {\r\n      // 这里的执行可能会出错，使用try\r\n      try {\r\n        // 入栈\r\n        effectStack.push(effect);\r\n        activeEffect = effect;\r\n        // 函数的执行会取值，取值会触发 createGetter方法\r\n        return fn();\r\n      } finally {\r\n        // 执行完了之后出栈\r\n        effectStack.pop();\r\n        // 吧activeEffect 设置为 最后一个 effect\r\n        // 这样就能保证 track 中的key 与 activeEffect对应上\r\n        activeEffect = effectStack[effectStack.length - 1];\r\n      }\r\n    }\r\n  };\r\n  // 只做标识\r\n  effect.id = uid++;\r\n  // 用于标识这个effect是个响应式effect\r\n  effect._isEffect = true;\r\n  // 保留 effect对应的原函数，创建映射关系\r\n  effect.raw = fn;\r\n  // 保存用户属性\r\n  effect.options = options;\r\n  return effect;\r\n}\r\n\r\n// 收集依赖\r\n// 能够拿到当前的 effect\r\n// 让某个对象中的属性收集当他对应的effect函数\r\nconst targetMap = new WeakMap();\r\nexport function track(target, type, key) {\r\n  activeEffect; // 当前正在运行的effect\r\n  //   至此各个effect之间的对应关系已经对应上\r\n  // console.log(target, type, activeEffect);\r\n  //   接下来属性和effect关联\r\n  if (activeEffect === undefined) {\r\n    // 此属性不需要收集依赖，因为没在effect中使用\r\n    return;\r\n  }\r\n\r\n  // 查看 weakMap 是否存在 target\r\n  let depsMap = targetMap.get(target);\r\n  // 不存在添加， key:Object value: Map\r\n  if (!depsMap) {\r\n    targetMap.set(target, (depsMap = new Map()));\r\n  }\r\n\r\n  // 在map 对象上查找对应key,\r\n  let dep = depsMap.get(key);\r\n  // 不存在 设置 此map 对象 key ,value： Set\r\n  if (!dep) {\r\n    depsMap.set(key, (dep = new Set()));\r\n  }\r\n\r\n  // 当前 ket 的value中是否存在 activeEffect,  不存在，添加进去\r\n  if (!dep.has(activeEffect)) {\r\n    dep.add(activeEffect);\r\n  }\r\n\r\n  // console.log(targetMap, \"targetMap\");\r\n}\r\n\r\n// 触发更新\r\n// 找属性对应的 effect 让其执行 （数组、 对象）\r\nexport function trigger(target, type, key?, newValue?, oldValue?) {\r\n  //\r\n  // console.log(target, type, key, newValue, oldValue);\r\n  // 如果当前属性没有收集过 effect, 不需要作任何操作\r\n  const depsMap = targetMap.get(target);\r\n  if (!depsMap) return;\r\n\r\n  // 将所有的要执行的effect 全部存到一个新的集合中，最后统一执行\r\n//   这里对 effect进行额去重\r\n  const effects = new Set();\r\n  const add = (effectToAdd) => {\r\n    if (effectToAdd) {\r\n      effectToAdd.forEach((effect) => effects.add(effect));\r\n    }\r\n  };\r\n\r\n  // 1、判断修改的是不是数组的长度，因为修改的是数组长度，影响较大\r\n  if (key === \"length\" && isArray(target)) {\r\n    // 如果对应的长度 有依赖是收集（注释：数组长度大于更新的长度）\r\n    depsMap.forEach((dep, key) => {\r\n      // console.log(dep, key);\r\n      // 修改长度必收集的索引小\r\n      if (key === \"length\" || key > newValue) {\r\n        // 如果更改的长度 小鱼收集的索引，那么这个索引也需要触发 effect重新更新\r\n        // dep 是个map对象\r\n        add(dep);\r\n      }\r\n    });\r\n  } else {\r\n    // 可能是对象\r\n    if(key !== undefined){ // 修改，不可能新增\r\n        add(depsMap.get(key)) // \r\n    }\r\n    // 如果修改数组中的某一个索引\r\n    // 如果是添加了一个树荫就出发长度的更新\r\n    switch(type){\r\n        case triggerOrTypes.ADD:{\r\n            if(isArray(target) && isIntegerKey(key)){\r\n                add(depsMap.get('length'))\r\n            }\r\n        }\r\n    }\r\n  }\r\n  effects.forEach((effect:any)=>{\r\n    if(effect.options.scheduler){\r\n      effect.options.scheduler(effect)\r\n    }else{\r\n      effect()\r\n    }\r\n  })\r\n}\r\n\r\n/**场景**/\r\n\r\n// 第一步：使用一个map 对象， key:｛name:test,age:123｝ value： map对象，这个对象的 key:name value:set\r\n// weakMap: key =》｛name:test,age:123｝  value：(map) => ｛name=> set｝\r\n// {name: 'test', age: 123} => name => [effect,effect]\r\n// 同时出现多个相同的effect\r\n// effect(()=>{\r\n//     state.name\r\n// })\r\n// effect(()=>{\r\n//     state.name\r\n// })\r\n\r\n// 由于使用了一个全局变量activeEffect,会出现问题，这里模拟出现问题的场景\r\n// 当出现函数嵌套时， 那么这个activeEffect就无法对应了\r\n// 解决方案;effectStack栈\r\n// 场景一 函数调用是一个栈结垢\r\n// effect(()=>{         effect1\r\n//     state.name       effect1\r\n//     effect(（）=>{    effect1\r\n//         state.age     effect2\r\n//     })\r\n//     state.addres     effect2\r\n// })\r\n\r\n// 当出现这中情况时，会出现死循环\r\n// 场景二\r\n// effect(() => {\r\n//     state.num++\r\n// })\r\n","import { isObject,extend,isArray,isIntegerKey,hasOwn,hasChanged } from \"@vue/shared\";\r\nimport {readonly,reactive} from './reactive'\r\nimport {track,trigger} from './effect'\r\nimport {TrackOpTypes,triggerOrTypes} from './operators'\r\n\r\n\r\n// 由于拦截方法不一样\r\n// 实现 new Proxy(target, handler)\r\n// 核心拦截\r\nfunction createGetter(isReadonly = false, shallow = false) {\r\n    return function get (target,key, receiver){\r\n         // proxy + reflect\r\n        //  补充：后续Object上的方法 会被转移到 Reflect, Reflect.getProptypeof（）\r\n        //  之前 target[key]=value方式设置可能会失败，并不会报异常，也没有返回值标识\r\n        // Reflect方法具备返回值\r\n        //  Reflect 使用可以不使用 proxy\r\n        const res = Reflect.get(target,key, receiver)\r\n        if(!isReadonly){\r\n            // 非只读，收集依赖，数据变化后更新对应视图\r\n            console.log('执行effect是会取值，收集 effect')\r\n            // \r\n            track(target, TrackOpTypes.GET,key)\r\n        }\r\n\r\n\r\n        // 浅层==》返回对象\r\n        if(shallow){\r\n            return res\r\n        }\r\n// 看返回时是不是对象，同时是不是readonly:reactive\r\n// 如果是只是 readonly不是只读递归转为响应式\r\n// vue2: 一上来就递归，vue3:当取值时会进行代理。vue3:代理模式为懒代理\r\n        if(isObject(res)){\r\n            return isReadonly ? readonly(res) : reactive(res)\r\n        }\r\n\r\n        return res\r\n    }\r\n}\r\n// 核心设置\r\nfunction createSetter(shallow = false) {\r\n    return function set (target,key, value, receiver){\r\n      const oldValue = target[key]\r\n\r\n //  1、新增 还是更新。 vue2无法监控更改索引， 无法监控数组长度\r\n     let hasKey =  isArray(target)&&isIntegerKey(key) ? Number(key) < target.length : hasOwn(target,key)\r\n        // proxy + reflect\r\n        const res = Reflect.set(target,key,value, receiver)\r\n\r\n\r\n        if(!hasKey){\r\n          \r\n          // 新增\r\n          trigger(target, triggerOrTypes.ADD, key, value)\r\n        }else if(hasChanged(value, oldValue)){\r\n          \r\n          // 修改\r\n          trigger(target, triggerOrTypes.SET, key, value, oldValue)\r\n        }\r\n        console.log('setter');\r\n       // 当数据更新时，通知对应属性的 effect重新执行\r\n      //  场景区分\r\n     \r\n\r\n\r\n\r\n        return res\r\n    }\r\n}\r\n\r\nconst get = createGetter();\r\nconst shallowGet = createGetter(false, true);\r\nconst readonlyGet = createGetter(true);\r\nconst shallowReadonlyGet = createGetter(true, true);\r\n\r\n// 提取合并方法\r\nconst set = createSetter();\r\nconst shallowSetter = createSetter();\r\n\r\n// 是不是只读：\r\n// 1、只读： set 会报异常\r\n// 2、是不是深度\r\nexport const mutableHandlers = {\r\n  get,\r\n  set,\r\n};\r\nexport const shallowReactiveHandlers = {\r\n  get: shallowGet,\r\n  set: shallowSetter,\r\n};\r\n\r\nlet readonlyObj = {\r\n  set: (target, key) => {\r\n    set: (target, key) => {\r\n      console.warn(`set on key ${key} field`);\r\n    };\r\n  },\r\n};\r\nexport const readOnlyHandlers = extend(\r\n  {\r\n    get: readonlyGet,\r\n  },\r\n  readonlyObj\r\n);\r\n\r\nexport const shallowReadonlyHandlers = extend(\r\n  {\r\n    get: shallowReadonlyGet,\r\n  },\r\n  readonlyObj\r\n);\r\n","import { isObject } from \"@vue/shared\";\r\nimport {mutableHandlers,shallowReactiveHandlers,readOnlyHandlers,shallowReadonlyHandlers} from './baseHandlers'\r\n\r\n\r\nexport function reactive(target) {\r\n  return createReactiveObject(target, false, mutableHandlers);\r\n}\r\n\r\nexport function shallowReactive(target) {\r\n  return createReactiveObject(target, false, shallowReactiveHandlers);\r\n}\r\n\r\n// 只读的调set方法报错\r\nexport function readonly(target) {\r\n  return createReactiveObject(target, true, readOnlyHandlers);\r\n}\r\n\r\nexport function shallowReadonly(target) {\r\n  return createReactiveObject(target, true, shallowReadonlyHandlers);\r\n}\r\n\r\n//  方法的区别 1、是否只读 2、是否深层响应 ==》柯里化\r\n//  new Proxy() 最核心hi需要拦截数据的读取和数据的修改 ==》 拦截 get set\r\n// 04、创建两个 weekMap（）,存储只读和响应式（优点：会自动垃圾回收）\r\nconst reactiveMap = new WeakMap();\r\nconst readonlyMap = new WeakMap();\r\n\r\nexport function createReactiveObject(target, isReadonly, baseHandlers) {\r\n  // 01、创建响应式对象，\r\n  //  如果目标对象不是对象,就没法拦截了，因为 reactive API 只对对象进行拦截\r\n  if (!isObject(target)) {\r\n    return target;\r\n  }\r\n\r\n  //  05、 创建只读和响应的映射表\r\n  const proxyMap = isReadonly ? readonlyMap : reactiveMap;\r\n\r\n  //  07、如果已经被代理了，直接返回即可\r\n  const existProxy = proxyMap.get(target);\r\n  if (existProxy) {\r\n    return existProxy;\r\n  }\r\n\r\n  //    02、创建代理\r\n  // 考虑：如果对象已经被代理了，就不需要在做代理,直接返回对象，但是这里分两种情况\r\n  //    1、可能为一个对象，被深度代理\r\n  //    2、又被只读代理了\r\n  const proxy = new Proxy(target, baseHandlers);\r\n  //   06、 将代理的对象和相应的代理结果换存起来\r\n  proxyMap.set(target, proxy);\r\n  // 03、返回proxy\r\n  return proxy;\r\n}\r\n","\r\nimport { hasChanged, isArray, isObject } from '@vue/shared';\r\nimport {track,trigger} from './effect'\r\nimport { TrackOpTypes, triggerOrTypes } from './operators';\r\nimport { reactive } from './reactive';\r\n// ref 和 reactive 的区别， reactive内部采用 proxy  ref 内部使用 defineProperty\r\nexport function ref(value){\r\n    // 将普通类型 变成一个对象。可以是对象，但是一般情况下直接使用 reactive\r\n   return createRef(value)\r\n}\r\n\r\nexport function shallowRef(value){\r\n    // 将普通类型 编程一个对象\r\n   return createRef(value, true)\r\n}\r\n\r\n// 这里判断如果是对象则用 reactive包裹， 否则 返回对象\r\nconst convert = (val) => isObject(val) ? reactive(val): val\r\n\r\nclass RefImpl{\r\n    public _value; // 表示 声明看了一个——value属性，但是没有赋值\r\n    public __v_isRef = true\r\n    constructor(public rawValue, public shallow){ // 参数前边增加修饰符， 表示此属性放到了实例上\r\n        \r\n        // \r\n    this._value = shallow ?  rawValue: convert(rawValue)\r\n    }\r\n    // 类的属性访问器\r\n    get value(){ // 取值取的 value , 会帮我们代理到 _value\r\n        // 取值时调用track()\r\n        track(this, TrackOpTypes.GET, 'value')\r\n        return this._value\r\n    }\r\n\r\n    set value(newValue){\r\n        if(hasChanged(newValue, this.rawValue)){\r\n            this.rawValue = newValue // 新增 会作为旧值， 下次在变动时进行对比\r\n            this._value =  this.shallow ?  newValue : convert(newValue)\r\n            trigger(this, triggerOrTypes.SET, 'value',newValue)\r\n        }\r\n       \r\n    }\r\n}\r\n\r\nfunction createRef(rowValue, shallow=false){\r\nreturn new RefImpl(rowValue, shallow)\r\n}\r\n\r\nclass ObjectRefImpl{\r\n    public __v_isRef = true\r\n    constructor(public target, public key){\r\n\r\n    }\r\n    get value(){// 代理\r\n        //  如果原对象是响应式就会收集依赖\r\n        return this.target[this.key]\r\n    }\r\n\r\n    set value(newValue){\r\n        // 如果远对象是响应式的，那么就会触发更新\r\n        this.target[this.key] = newValue\r\n    }\r\n}\r\n\r\n// 可以吧一个对象的值转化为ref类型\r\n// 将某一个key 对应的值转化为ref\r\nexport function toRef(target, key){\r\n    return new ObjectRefImpl(target, key)\r\n\r\n}\r\n\r\n// 这个object可能时 object 也可能是个 array\r\nexport function toRefs(object){\r\n    // 这里做一个判断 如果是数组，创建一个相同长度的数组\r\n    const ret = isArray(object) ? new Array(object.length) : {}\r\n    // 循环调用，把所有的属性都转为 key:value形式\r\n    for(let key in object){\r\n        ret[key] = toRef(object,key)\r\n    }\r\n}","import { isFunction } from \"@vue/shared\";\r\nimport {effect,track, trigger} from './effect'\r\nimport {TrackOpTypes, triggerOrTypes} from './operators'\r\n\r\n\r\n// 缓存 computed effect（lazy）+scheduler + 缓存标识\r\n\r\nclass ComputedRefImpl{\r\n    public _dirty = true // 默认取值时不要用缓存\r\n    public _value\r\n    public effect\r\n    // 计算属性本身就是一个effect\r\n    constructor(getter,public setter){ // ts中默认不会挂载到this上\r\n        this.effect = effect(getter,{ // 计算属性会默认产生一个effect,默认不执行,只有取值时才执行\r\n            lazy:true,\r\n            scheduler: ()=>{\r\n                if(!this._dirty){\r\n                    this._dirty = true\r\n                    trigger(this, triggerOrTypes.SET, 'value')\r\n                }\r\n            }\r\n        })\r\n       \r\n    }\r\n    get value(){ // vue2中计算双属性不具备收集依赖\r\n        if(this._dirty){ // 如果是脏的(第一次)会执行effect\r\n          this._value =   this.effect() // 执行会将用户返回值返回\r\n          this._dirty = false\r\n        }\r\n        // 这里作收集依赖\r\n        // 收集依赖场景::\r\n        // let age = ref(18);\r\n        // const myAge = computed(() => {\r\n        //   console.log(\"runner\");\r\n        //   return age.value + 10;\r\n        // });\r\n  \r\n        // effect(() => {\r\n        //   console.log(myAge.value);\r\n        // });\r\n        // age.value = 500;\r\n\r\n        track(this, TrackOpTypes.GET, 'value')\r\n        // 这样多次执行后智慧取第一次执行的结果\r\n        return this._value\r\n    }\r\n\r\n    set value(newVal){\r\n        this.setter(newVal)\r\n    }\r\n}\r\n\r\n//  vue2 和 vue3computed 原理不一样\r\nexport function computed(getterOrOptions){\r\n    let getter;\r\n    let setter;\r\n\r\n    if(isFunction(getterOrOptions)){\r\n        getter = getterOrOptions\r\n        setter = () => {\r\n            console.warn('computed value must be readonly')\r\n        }\r\n    } else{\r\n        getter = getterOrOptions.get\r\n        setter = getterOrOptions.set\r\n    }\r\n    // 创建计算属性\r\n    return new ComputedRefImpl(getter,setter)\r\n}"],"names":[],"mappings":"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"}